My idea is to create a service status dashboard for the servers I already host (Apache Webserver, ESXI, Minecraft, Pterodactyl).

Features:

Dashboard - Will allow me to view the status of all my servers at a glance and have the ability to add additional servers.

Log Aggregation - A more detailed view as the aggregator will collect logs from the servers and present them to you. There will be alerts for serious errors in the logs and it will allow for advanced log filtering and views.

Branching Strategy:
The initial branching strategy is to have a unique branch per feature before merging to main.

Branching Usage Reflections:
I will call the first branch "dashboard_view" as the initial feature.

Wireframes:
-Login page: Since there is information about internal services, a login page is needed.
-Main Page: This page will show the status of your services and allow you to add more.

Django Setup:
Initialized the django project.
I called the initial app "dashboard_view" for the main screen. I also plan on adding "login" later. The project is called service_dashboard because that is the overall goal of the project.

Environment:
I am using a virtual environment called "django3". This virtual environment will hold django and any other libraries I find I need. If the 2 project libraries diverge, I will create seperate environments for both of them.




Why these models/fields:
For the center of the project, everything revolves around the monitoring_service, which is why it is situated at the center of the ERD. For the monitoring app, I needed info about the server, service type,the service itself, probe: which will actually manage communication with the service, and the checkresult which stores the result of the check.
The server holds information regarding the server the actual service resides on and each server can have multiple services. The servicetype is a descriptor of the service, and can be used many times, as there may be multiple minecraft servers, for example.
Each service can also have multiple probes, each getting a specific aspect if needed. The checkresult holds multiple results for one probe.

The logging_app also takes advantage of monitoring_service,as it already has information about how to get access to the server/service. Furthermore, there can be multiple logsources per service, for example, an apache web server can have multiple log files.

The logevent will store the actual line-by line logfile. Naturally, there can be multiple log events per log source.

Completely separate from everything else, we have dashboard_view_user, and loginaudit. The user will be the user that actually uses the dashboard and can be categorised as an owner, admin, user, etc. Each login will be logged in loginaudit. Each user has a loginaudit, but not all loginaudits have users.

Relationship Choices:
I went over the relationships in regards to foreign keys in the previous text, but as to the on_delete rationale, I went for a hierarchical approach. For example, the monitoring service has foreign keys for its monitoring server and monitoring servicetype.
When servicetype or server are deleted, the monitoring service is also deleted. This cascades, as it then deletes the logsource (as it is now gone) and the logevents are also deleted.


Constraints:
While I did not use any ordering for the moment, I did have many other constraints. Most common is constraints on length to help save space. If I know how large something will be, I can ensure that no space more than that is used.
I also used unique for servicetype name. Since this is a descriptive name, having multiple of the same name defeats its purpose. I also ensure that the username is unique.
Lastly, for the user itself, I added the editable=false to "password". Since I don't know how to properly store passwords, I will ensure no passwords can be stored.


Seeding test data:
Since I didn't know how to properly create a user, I ignored it for this part and focused on the primary goal of having monitoring. I did this by first adding a couple servers with different IP addresses and hypothetical locations and OS.
After that, I added service types with 2 different services.
With this complete, I can add the actual service now. I added 2 services using the server and service types previously created with different data. After that, I can create multiple probes for the servers.
Each of those probes has multiple checkresults with different errors or results.
After that, I can add a logsource, using the service as the source. Each of those log sources then has different events.

What this did was really make me see the connections between the data. I can't create a service without having a server and a service type, and probes need a service, and so on.



A4 Views Notes:
I wrote the view login as I eventually will need a login screen. It was also a good example of manual HTTP sending. Since it's a static page, it's very simple to just render and send an HTML page to the user.
For render, I used the logging app view. This is better, since I need to pass data to the template from the view, and the render function makes it very easy to do compared to manual HTTP repsonse.
I Used the list view class for my monitoring page. I consider this even easier than the render option. Just by passing my data and the template, everything is pretty much done for you.

For the URL design. I decided to have the main URL point to each URL within the app. This will let me organize my URLs much more effectively, allowing me to understand why each URL exists and how to manage it.
The templates currently are just basic dashboards. I am pretty satisfied with my monitoring view. It shows only what you need to know, the service and status, and will later allow the user to click on it to get more information.
The log view is currently okay. It works similarly to the dashboard, but with there being a lot more logs, I may need to make it smaller or change the format later. I also need to add search and sort functionalities, so I don't think the current form is sufficient.


A5 Notes:
Base and generic class based views are very similar. In fact, while reading some of the documentation for the base view, I found that all generic views inherit the base view. As such, the base view is a simple version that still lets you set up views quickly.
Generic views are more diverse in their actions and purposes. For more specific purposes, you probably want to use a generic view instead of a base view.

These class base views are really helpful. They improve readability by simplifying and standardizing the view, they make it easier for you to create more complex tasks, and reduce the amount of code you have to write.

Refactoring urls is also important. By standardizing the way urls are used and using dynamic urls instead of static ones, you do a couple things. First, if a URL is changed, you don't have to search your code for every place you referenced this URL and change it
to avoid dead links. Second, you save yourself time by writing shorter code and not having to remember long urls.

A6 Notes:
This week was pretty simple. I had already added a search functionality in the previous week so adding aggregations was only a few extra lines of code. I decided to add this to the logs. This allows you to see the total logs and the types of errors it contains.

Filtering is done early and allows you to modify the query and results of the database. This is done in the search functionality. Aggregation is also somewhat similar, allowing you to group similar information for various purposes. In my project, I group by status
count to show the user unique log types and their counts.


A7 Notes:

Static files are generally css and images that you want to reference in your project. Having a single organized location for these files makes the code a lot cleaner and improves readability.

For my chart, I chose to show the frequency of log types. This uses the count aggregation to find the total of each type of error. This is then displayed on a pie chart. While I didn't initally plan on having any charts,
if I were to include them, it would be in the logs. Due to the way logs work, you tend to get tons of them which makes seeing the big picture difficult. A visual representation of counts can act as a warning sign if something
starts occurring a lot more than usual.

 BytesIO is a neat little tool that lets you store information directly on memory instead of disk. This can help save disk space and let you access the info easily and quickly.
 Tight_layout is a matplotlib function that improves readability by ensuring that all elements are displayed correctly and adjusting space as needed.

A8 Notes:
Cross Site Request Forgery (CSRF) takes advantage of the trust sites have for logged-in users. Malicious users may take advantage of this by sending a request to another site you have open. This can be scary as this request is completely
invisible to the user and doesn't require any user input. By using a cross site request forgery token, we are able to protect against this by using a secret token. If a malicious user tries to send a bad request, they won't have the
token and their request won't go through.

The form submission process of django is pretty simple. A user visits a page and gets served a form. The forms of that field are defined in forms.py and include some basic data cleaning processes. Once the user clicks submit, the data
goes back to the views where it is processed by some logic, allowing the programmer to determine what happens if data is invalid. If it is valid, it is saved to the database and the programmer can once again choose what to do (show
a success message, redirect, etc). This is similar to the MVT process but forms.py is also involved.

Function based views and class based views also have a role in forms. They both have a purpose. Function based views are more difficult to make and take more code but allow for more flexibility. Class based views are super easy and
quick to make due to essentially plugging a few variables into a premade template. The con is if you need some advanced functionality that isn't built in, it may be more difficult.

Get and post are different ways of sending data to the server. Get essentially encodes the data in the URL, allowing it to be bookmarked and being lightweight, but comes at the cost of privacy and security. Post is a secure way of sending
data to the server.

A9 Notes:
A JSON api is an endpoint which allows users or internal applications to access clean json data. This allows the programmer to create charts quickly or outside users to access the data from the API in a normal format that can be uses for a variety
of purposes.

HttpResponse and JsonResponse are both pretty similar. JsonResponse returns a formatted JSON response to any request. This is a formatted data type that allows people who access it to use it for further programming or charts. HTTPresponse is a manual
way of sending a response where the programmer decides the format. It can vary from HTML, text files, image files, etc. This is flexible and allows the programmer to use it to approach any problem.

The data flows from the url, which directs traffic to the view. This allows you to access it from other views or even from outside the applicaton. In our chart, we access this api within the application to get data. This data is formatted with
matplotlib, and then inserted into a template which is served to the user accessing the site.

A10 Notes:
While I will likely access APIs in my project, they will be private, so for this project, I used the US government weather api. This will allow me to practice using an API even if I don't implement it in my project.

For what fields I accessed, I access a couple. The first call get a response that directs me to another api for weather based on my location. For this, I access the link to the hourly forcast. Then, I make a call to that API and access the actual weather which I send back to my AJAX instance.

I manage errors by using a try/except block that catches any HTML errors, and then I have a JS script in my template that shows the type of error that was raised.

The final JSON is presented as a list, showing the weather at each hour, with the cords used at the top.

One thing I noticed is this api is really slow. I didn't include a timeout for this reason. Visiting the site, you will notice that there can be a substantial delay before the forcast shows up. It also took a while to get everything wired up as it has a ton of fields.